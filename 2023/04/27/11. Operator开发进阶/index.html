<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		Operator开发进阶 | 
	 
	Hexo
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>


	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@v1.5.1/dist/Valine.min.js"></script>

	
	

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">Hexo</a>

	<ul id="menu">
    

    

    

    
      
      
        <li class="menu-item">
          <a href='https://github.com/NikeSong' class="menu-item-link" target="_blank">
            Nicolson
          </a>
        </li>
      
        <li class="menu-item">
          <a href='https://github.com/NikeSong' class="menu-item-link" target="_blank">
            Nicolson
          </a>
        </li>
      
    
  
    
      <li class="menu-item">
        <a href='https://github.com/NikeSong' class="menu-item-link" target="_blank">
          <i class="fa fa-github fa-2x"></i>
        </a>
      </li>
    
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="file">
									<a href="/2023/04/23/1.%20Kubernetes%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">
                     
										    Kubernetes基本结构
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/28/10.%20%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Client-go%E5%AE%9E%E7%8E%B0%E6%9C%BA%E7%90%86/">
                     
										    深入学习Client-Go实现机理
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2023/04/27/11.%20Operator%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/">
                     
										    Operator开发进阶
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/28/12.%20Deployment%20Controller%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
                     
										    Deployment Controller源码分析
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/23/2.%20Pod%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/">
                     
										    Pod细节分析
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/24/3.%20K8s%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/">
                     
										    K8s服务暴露
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/24/4.%20%E6%8E%A2%E7%A7%98Docker%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">
                     
										    探秘Docker容器的实现原理
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/25/5.%20%E4%BB%80%E4%B9%88%E6%98%AFOperator/">
                     
										    什么是Operator
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/25/6.%20%E5%B0%9D%E8%AF%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Pod%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%99%A8/">
                     
										    尝试开发一个简单的Pod管理控制器
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/26/7.%20%E3%80%90%E6%95%85%E9%9A%9C%E3%80%91K8s%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%87%BA%E9%97%AE%E9%A2%98/">
                     
										    【故障】K8s组件版本出问题
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/27/7.5.%20%E3%80%90%E6%95%85%E9%9A%9C%E3%80%91%E4%B8%80%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%99%BB%E9%99%86%E4%B8%8D%E8%BF%9B%E5%8E%BB%E4%BA%86/">
                     
										    【故障】一台虚拟机登陆不进去了
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/27/8.%20k8s%20api%E5%AD%A6%E4%B9%A0/">
                     
										    Kubernetes api学习
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/28/9.%20GVK-%E7%BB%84%E3%80%81%E7%89%88%E6%9C%AC%E5%92%8C%E7%B1%BB%E5%9E%8B/">
                     
										    GVK和GVR
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">
	Operator开发进阶
</h1>

<!-- meta -->
<div class="article-meta">
	

	<span>John Doe</span>
	<span>2023-04-27 21:47:16</span>

  <div id="article-categories">
    
		  <span>Categories：</span>
      
          
              <span>
                  <i class="fa fa-folder" aria-hidden="true">
                  <a href="/categories/Kubernetes学习笔记/">Kubernetes学习笔记</a>
                  </i>
                
              </span>
          
      
    

    
		    <span>Tags：</span>
        
    
  </div>

</div>

<!-- content -->
<div id="article-content">
	<p>一般我们需要将一个应用部署到Kubernetes中时，都会选择用Deployment来管理应用，用Service来做服务发现，进一步可能还需要配置ConfigMap、Ingress、Secret等资源。这么多类型资源的创建、维护、管理工作会变得烦琐且复杂。</p>
<blockquote>
<p>部署在K8s中的应用：</p>
<ul>
<li>Deployment等controler做管理</li>
<li>Service做服务发现</li>
<li>ConfigMap做配置存储</li>
<li>Ingress解决暴露多个Service的需求。</li>
<li>Secret存储敏感信息</li>
</ul>
</blockquote>
<p>我们可以通过Operator在一个应用部署所需的各种资源之上抽象一个Application类型，这个类型里包含必要的一些字段，然后用户只需要创建一个Application，我们通过自定义控制器去完成Application相关的Deployment、Service、ConfigMap等资源的创建和管理工作。</p>
<h3 id="1-初始化项目"><a class="markdownIt-Anchor" href="#1-初始化项目"></a> 1. 初始化项目</h3>
<p>初始化，别忘了vpn就完事了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master MyOPeratorProjects]# mkdir application-operator2</span><br><span class="line">[root@master MyOPeratorProjects]# cd application-operator2</span><br><span class="line">[root@master application-operator2]# ls</span><br><span class="line">[root@master application-operator2]# kubebuilder init --domain=danielhu.cn --repo=github.com/daniel-hutao/application-operator --owner Daniel.Hu</span><br></pre></td></tr></table></figure>
<p>项目名默认是application-operator，项目名和文件夹名字一致。这里需要知道的是项目名体现在哪些地方，找到这些配置项，手动调整即可：<br />
1）PROJECT文件中的projectName配置。<br />
2）config/default/kustomization.yaml文件中的namespace配置。<br />
3）config/default/kustomization.yaml文件中的namePrefix配置。</p>
<p><strong>这次更深入的看看项目的基础结构</strong></p>
<ul>
<li>go.mod：包含了项目的基础依赖。</li>
<li>Makefile：存放的是和开发过程中构建、部署、测试等相关的一系列命令。</li>
<li>PROJECT：存放的是一些Kubebuilder需要用到的元数据。</li>
<li>部署配置：还有很多与Operator部署相关的配置文件保存在config目录下，主要是运行Controller相关的Kustomize配置以及各种资源配置。</li>
<li>main.go：
<ul>
<li>文件中首先是注释内容，我们之前提到过每个源文件开头的Copyright声明来自hack/boilerplate.go.txt文件，并且这里会自动加上在kubebuilder init命令中使用–owner=Daniel Hu所指定的作者签名。</li>
<li>接下来是import部分。<a target="_blank" rel="noopener" href="http://xn--sigs-zh5fpp39nwtzzyhvvq3if533clu1ctts4vg.k8s.io/controller-runtime%E4%BE%9D%E8%B5%96%E5%8C%85%EF%BC%8C%E5%85%B6%E4%BB%96%E5%8C%85%E5%9C%A8%E5%90%8E%E9%9D%A2%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%86%8D%E6%9D%A5%E5%85%B7%E4%BD%93%E7%9C%8B%E5%85%B6%E4%BD%9C%E7%94%A8%E3%80%82">这里主要是导入了核心的sigs.k8s.io/controller-runtime依赖包，其他包在后面使用的时候再来具体看其作用。</a></li>
<li>剩下的逻辑：
<ul>
<li>在main()函数中先设置了一些与metrics相关的标志（flags）</li>
<li>实例化了一个Manager对象，Manager负责跟踪维护和运行所有的Controllers</li>
<li>同时也设置了共享缓存以及和kube-apiserver通信用的各种Clients</li>
<li>在main()函数中通过Start()方法启动了Manager，Manager运行后反过来会启动所有Controller和Webhook。</li>
<li>这个Manager会一直运行在后台，直到接收到“优雅停止”信号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-定义application资源"><a class="markdownIt-Anchor" href="#2-定义application资源"></a> 2. 定义Application资源</h3>
<h4 id="21-api结构分析"><a class="markdownIt-Anchor" href="#21-api结构分析"></a> 2.1 API结构分析</h4>
<p>和第一次实验一样，这里我们需要创建Application类型和其对应的控制器，其命令是kubebuilder create api：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master application-operator2]# kubebuilder create api --group apps --version v1 --kind Application</span><br><span class="line">Create Resource [y/n]</span><br><span class="line">y</span><br><span class="line">Create Controller [y/n]</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<p>此时项目路径有一次出现了 api / vi</p>
<p><strong>分析</strong></p>
<p>对于一个新的group-version，也就是组和版本都相同的一个资源类型，kubebuilder create api命令会新建一个目录来存放这个group-version。<a target="_blank" rel="noopener" href="http://xn--apps-4m5f5hu47f1man1pb4bux9jduwc.danielhu.cn/v1%E8%BF%99%E4%B8%AAgroup-version%E3%80%82%E8%BF%98%E8%AE%B0%E5%BE%97%E6%88%91%E4%BB%AC%E7%94%A8%E7%9A%84%E5%8F%82%E6%95%B0--group">该目录也就对应了apps.danielhu.cn/v1这个group-version。还记得我们用的参数--group</a> apps吗？group名会自动加上一开始新建项目时使用–domain所指定的danielhu.cn域名，<a target="_blank" rel="noopener" href="http://xn--apps-4m5f5htxz03ar1sqnn7oa.danielhu.cn">所以也就变成了apps.danielhu.cn</a>。</p>
<p>打开application_types.go文件，有关Copyright部分就不用说了，import部分可以看到只有简单的一行依赖：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	metav1 <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>后面接着是Application类型对应的Spec和Status结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationSpec defines the desired state of Application</span></span><br><span class="line"><span class="keyword">type</span> ApplicationSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster</span></span><br><span class="line">	<span class="comment">// Important: Run &quot;make&quot; to regenerate code after modifying this file</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Foo is an example field of Application. Edit application_types.go to remove/update</span></span><br><span class="line">	Foo <span class="type">string</span> <span class="string">`json:&quot;foo,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplicationStatus defines the observed state of Application</span></span><br><span class="line"><span class="keyword">type</span> ApplicationStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster</span></span><br><span class="line">	<span class="comment">// Important: Run &quot;make&quot; to regenerate code after modifying this file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道Operator的核心逻辑就是不断调谐资源对象的实际状态和期望状态（Spec）保持一致。这里的Status当然不是严格对应“实际状态”，而是观察并记录下来的当前对象最新“状态”。大多数资源对象都有Spec和Status两个部分，但是也有部分资源对象不符合这种模式，比如ConfigMap之类的静态资源对象就不存在着“期望的状态”这一说法。</p>
<p>继续往下可以看到对应Application类型的结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Application is the Schema for the applications API</span></span><br><span class="line"><span class="keyword">type</span> Application <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta   <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">	metav1.ObjectMeta <span class="string">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class="line"></span><br><span class="line">	Spec   ApplicationSpec   <span class="string">`json:&quot;spec,omitempty&quot;`</span></span><br><span class="line">	Status ApplicationStatus <span class="string">`json:&quot;status,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//+kubebuilder:object:root=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplicationList contains a list of Application</span></span><br><span class="line"><span class="keyword">type</span> ApplicationList <span class="keyword">struct</span> &#123;</span><br><span class="line">	metav1.TypeMeta <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">	metav1.ListMeta <span class="string">`json:&quot;metadata,omitempty&quot;`</span></span><br><span class="line">	Items           []Application <span class="string">`json:&quot;items&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Application结构体是Application类型的“根类型”，和其他所有的Kubernetes资源类型一样包含TypeMeta和ObjectMeta。TypeMeta中存放的是当前资源的Kind和APIVersion信息，ObjectMeta中存放的是Name、Namespace、Labels和Annotations等信息。<br />
而ApplicationList其实只是简单的一个Application集合类型，其中通过Items存放一组Application，用于List之类的批量操作。<br />
一般情况下，这两个对象都是不需要修改的，我们修改的是前面提到的ApplicationSpec和ApplicationStatus两个结构体。<br />
另外，我们还看到上面的代码中有一行//+kubebuilder:object:root=true这样的特殊注释标记。这个标记主要是被controller-tools识别，然后controller-tools的对象生成器就知道这个标记下面的对象代表一个Kind，接着对象生成器会生成相应的Kind需要的代码，也就是实现runtime.Object接口。换言之，一个结构体要表示一个Kind，必须实现runtime.Object接口。</p>
<p>最后还有一个init()函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	SchemeBuilder.Register(&amp;Application&#123;&#125;, &amp;ApplicationList&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="22-自定义新api"><a class="markdownIt-Anchor" href="#22-自定义新api"></a> 2.2 自定义新API</h4>
<p>接下来定义自己的API，将Application改成需要的样子。如下所示，在ApplicationSpec中添加Deployment和Service属性，类型分别为DeploymentTemplate和ServiceTemplate：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationSpec defines the desired state of Application</span></span><br><span class="line"><span class="keyword">type</span> ApplicationSpec <span class="keyword">struct</span> &#123;</span><br><span class="line">	Deployment DeploymentTemplate <span class="string">`json:&quot;deployment,omitempty&quot;`</span></span><br><span class="line">	Service    ServiceTemplate    <span class="string">`json:&quot;service,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步是定义DeploymentTemplate和ServiceTemplate。在这里我们简单地引用Kubernetes原生的DeploymentSpec对象和ServiceSpec对象来构造DeploymentTemplate和ServiceTemplate。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeploymentTemplate <span class="keyword">struct</span> &#123;</span><br><span class="line">	appsv1.DeploymentSpec <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceTemplate <span class="keyword">struct</span> &#123;</span><br><span class="line">	corev1.ServiceSpec <span class="string">`json:&quot;,inline&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着是状态的定义。当然，这里不需要太复杂的逻辑，同样是简单地引用Kubernetes原生的DeploymentStatus对象和ServiceStatus对象来实现状态管理逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationStatus defines the observed state of Application</span></span><br><span class="line"><span class="keyword">type</span> ApplicationStatus <span class="keyword">struct</span> &#123;</span><br><span class="line">	Workflow appsv1.DeploymentStatus <span class="string">`json:&quot;workflow&quot;`</span></span><br><span class="line">	Network  corev1.ServiceStatus    <span class="string">`json:&quot;network&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-实现application-controller"><a class="markdownIt-Anchor" href="#3-实现application-controller"></a> 3. 实现Application Controller</h3>
<h4 id="31-实现主调谐流程"><a class="markdownIt-Anchor" href="#31-实现主调谐流程"></a> 3.1 实现主调谐流程</h4>
<p>Application资源定义好之后，当然就要开始写控制器的核心调谐逻辑了。打开controllers/application_controller.go源文件，我们可以看到Reconcile方法的骨架。接下来要实现的调谐逻辑大致如下所示。我们先查看代码，然后对照流程图中的步骤来详细解释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ApplicationReconciler)</span></span> Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, <span class="type">error</span>) &#123;</span><br><span class="line">	&lt;-time.NewTicker(<span class="number">100</span> * time.Millisecond).C</span><br><span class="line">	log := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">	CounterReconcileApplication += <span class="number">1</span></span><br><span class="line">	log.Info(<span class="string">&quot;Starting a reconcile&quot;</span>, <span class="string">&quot;number&quot;</span>, CounterReconcileApplication)</span><br><span class="line"></span><br><span class="line">	app := &amp;dappsv1.Application&#123;&#125;</span><br><span class="line">	<span class="keyword">if</span> err := r.Get(ctx, req.NamespacedName, app); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">			log.Info(<span class="string">&quot;Application not found.&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		log.Error(err, <span class="string">&quot;Failed to get the Application, will requeue after a short time.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// reconcile sub-resources</span></span><br><span class="line">	<span class="keyword">var</span> result ctrl.Result</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line">	result, err = r.reconcileDeployment(ctx, app)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(err, <span class="string">&quot;Failed to reconcile Deployment.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> result, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result, err = r.reconcileService(ctx, app)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(err, <span class="string">&quot;Failed to reconcile Service.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> result, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Info(<span class="string">&quot;All resources have been reconciled.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../images/tiao_xie.png" alt="tiao_xie" /></p>
<h5 id="311-计数器"><a class="markdownIt-Anchor" href="#311-计数器"></a> 3.1.1 计数器</h5>
<pre><code>&lt;-time.NewTicker(100 * time.Millisecond).C
log := log.FromContext(ctx)

CounterReconcileApplication += 1
log.Info(&quot;Starting a reconcile&quot;, &quot;number&quot;, CounterReconcileApplication)
</code></pre>
<p>由于调谐过程是并发执行的，也就是说，如果同时创建3个Application类型的资源实例，这时3个事件会同时被处理，日志会比较混乱，所以我们在开头加了一个100毫秒的等待，同时在后面加了一个计数器CounterReconcileApplication，并打印一条日志来输出当前是第几轮调谐。这里不用担心这个数字会溢出，大家如果感兴趣可以计算一下int64有多大，是不是能够让这个程序运行100年也不用担心这里的计数器溢出。CounterReconcileApplication的声明是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CounterReconcileApplication <span class="type">int64</span></span><br></pre></td></tr></table></figure>
<h5 id="312-查询对应的application"><a class="markdownIt-Anchor" href="#312-查询对应的application"></a> 3.1.2 查询对应的Application</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app := &amp;dappsv1.Application&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := r.Get(ctx, req.NamespacedName, app); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> errors.IsNotFound(err) &#123;</span><br><span class="line">		log.Info(<span class="string">&quot;Application not found.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	log.Error(err, <span class="string">&quot;Failed to get the Application, will requeue after a short time.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先实例化了一个*v1.Application类型的app对象，然后通过r.Get()方法查询触发当前调谐逻辑对应的Application，将其写入app。<br />
接着我们需要处理err != nil的情况，错误分为两种：Application不存在与其他错误。如果是Application不存在，我们的处理是打印一条日志，然后直接返回ctrl.Result{},nil，也就是意味着“本轮调谐结束”。因为不管是出于什么原因导致Application不存在，比如是被删除了，这时控制器不管进行什么处理都是没有意义的。如果之后不久Application又被创建出来，那么这个调谐过程会被再次触发。所以当前调谐过程只需要直接退出就行了。除此以外的错误，我们需要通过重试来处理，所以除了错误日志打印外，还需要返回ctrl.Result{RequeueAfter:GenericRequeueDuration},err，也就是在1分钟后再次触发本函数调谐。这里的GenericRequeueDuration定义在文件开头：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> GenericRequeueDuration = <span class="number">1</span> * time.Minute</span><br></pre></td></tr></table></figure>
<h5 id="313-调谐deployment"><a class="markdownIt-Anchor" href="#313-调谐deployment"></a> 3.1.3 调谐Deployment</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reconcile sub-resources</span></span><br><span class="line"><span class="keyword">var</span> result ctrl.Result</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"></span><br><span class="line">result, err = r.reconcileDeployment(ctx, app)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Error(err, <span class="string">&quot;Failed to reconcile Deployment.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将主要逻辑封装到reconcileDeployment()方法中去实现，从而让主调谐函数看起来可读性更好。当然，reconcileDeployment()方法要做的事情就是完成Deployment资源的调谐过程，然后返回对应的result和error，对于主调谐函数Reconcile()来说，只需要在reconcileDeployment()方法返回的error不等于nil的时候直接返回这个result和error即可。</p>
<h5 id="314-调谐service"><a class="markdownIt-Anchor" href="#314-调谐service"></a> 3.1.4 调谐Service</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result, err = r.reconcileService(ctx, app)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Error(err, <span class="string">&quot;Failed to reconcile Service.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service的调谐方式和Deployment基本是一样的，我们同样封装到一个名为reconcileService()的方法中。上面的Deployment调谐过程如果没有任何错误，代码逻辑就会继续走到Service的调谐，最后如果Service的调谐过程没有任何错误，那么主调谐函数的任务就算完成了。所以最后的逻辑是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log.Info(<span class="string">&quot;All resources have been reconciled.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<h4 id="32-实现deployment调谐流程"><a class="markdownIt-Anchor" href="#32-实现deployment调谐流程"></a> 3.2 实现Deployment调谐流程</h4>
<p>在实现控制器的主调谐逻辑时，我们留了两个待实现的子调谐逻辑，也就是reconcileDeployment()方法和reconcileService()方法。接下来，自然是需要实现这两个方法了，我们先从reconcileDeployment()方法开始。<br />
在controllers目录下，与application_controller.go源文件同级目录内创建一个deployment.go源文件来实现Deployment的调谐逻辑。<br />
我们要实现的Deployment调谐逻辑大致如下图所示。</p>
<p><img src="../images/deployment_reconcile.png" alt="deployment_reconcile" /></p>
<p>同样先查看代码，然后对照流程图中的步骤来详细分析：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ApplicationReconciler)</span></span> reconcileDeployment(ctx context.Context, app *dappsv1.Application) (ctrl.Result, <span class="type">error</span>) &#123;</span><br><span class="line">	log := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> dp = &amp;appsv1.Deployment&#123;&#125;</span><br><span class="line">	err := r.Get(ctx, types.NamespacedName&#123;</span><br><span class="line">		Namespace: app.Namespace,</span><br><span class="line">		Name:      app.Name,</span><br><span class="line">	&#125;, dp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Info(<span class="string">&quot;The Deployment has already exist.&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> reflect.DeepEqual(dp.Status, app.Status.Workflow) &#123;</span><br><span class="line">			<span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		app.Status.Workflow = dp.Status</span><br><span class="line">		<span class="keyword">if</span> err := r.Status().Update(ctx, app); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Error(err, <span class="string">&quot;Failed to update Application status&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		log.Info(<span class="string">&quot;The Application status has been updated.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !errors.IsNotFound(err) &#123;</span><br><span class="line">		log.Error(err, <span class="string">&quot;Failed to get Deployment, will requeue after a short time.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newDp := &amp;appsv1.Deployment&#123;&#125;</span><br><span class="line">	newDp.SetName(app.Name)</span><br><span class="line">	newDp.SetNamespace(app.Namespace)</span><br><span class="line">	newDp.SetLabels(app.Labels)</span><br><span class="line">	newDp.Spec = app.Spec.Deployment.DeploymentSpec</span><br><span class="line">	newDp.Spec.Template.SetLabels(app.Labels)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := ctrl.SetControllerReference(app, newDp, r.Scheme); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(err, <span class="string">&quot;Failed to SetControllerReference, will requeue after a short time.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := r.Create(ctx, newDp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(err, <span class="string">&quot;Failed to create Deployment, will requeue after a short time.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Info(<span class="string">&quot;The Deployment has been created.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="321-查询deployument"><a class="markdownIt-Anchor" href="#321-查询deployument"></a> 3.2.1 查询Deployument</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dp = &amp;appsv1.Deployment&#123;&#125;</span><br><span class="line">err := r.Get(ctx, types.NamespacedName&#123;</span><br><span class="line">	Namespace: app.Namespace,</span><br><span class="line">	Name:      app.Name,</span><br><span class="line">&#125;, dp)</span><br></pre></td></tr></table></figure>
<p>这一步比较常规，先根据Application的Namespace和Name信息来查询对应Deployment是否存在。</p>
<h5 id="322-没有错误发生时更新状态"><a class="markdownIt-Anchor" href="#322-没有错误发生时更新状态"></a> 3.2.2 没有错误发生时，更新状态</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Info(<span class="string">&quot;The Deployment has already exist.&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> reflect.DeepEqual(dp.Status, app.Status.Workflow) &#123;</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	app.Status.Workflow = dp.Status</span><br><span class="line">	<span class="keyword">if</span> err := r.Status().Update(ctx, app); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(err, <span class="string">&quot;Failed to update Application status&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	log.Info(<span class="string">&quot;The Application status has been updated.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Deployment的status更新引起的调谐过程被触发。所以接下来判断dp.Status和app.Status.Workflow是否相等，如果不相等，则说明app.Status.Workflow需要更新。<br />
这里大家应该注意到Status更新用的是r.Status().Update()方法。</p>
<h5 id="323-notfound之外的错误场景"><a class="markdownIt-Anchor" href="#323-notfound之外的错误场景"></a> 3.2.3 NotFound之外的错误场景</h5>
<p>如果错误是NotFound，那么意味着需要创建一个新的Deployment资源实例，这个逻辑很明确，可以预见会有十几到二十行代码。而错误不是NotFound的时候呢？我们只能结束本轮调谐逻辑，选择指定一段时间后去重试。所以我们先写!NotFound的逻辑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !errors.IsNotFound(err) &#123;</span><br><span class="line">	log.Error(err, <span class="string">&quot;Failed to get Deployment, will requeue after a short time.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="324-notfound的时候"><a class="markdownIt-Anchor" href="#324-notfound的时候"></a> 3.2.4 NotFound的时候</h5>
<p>大家应该猜到了，这时要做的就是根据Application资源实例的信息来构造Deployment实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">newDp := &amp;appsv1.Deployment&#123;&#125;</span><br><span class="line">newDp.SetName(app.Name)</span><br><span class="line">newDp.SetNamespace(app.Namespace)</span><br><span class="line">newDp.SetLabels(app.Labels)</span><br><span class="line">newDp.Spec = app.Spec.Deployment.DeploymentSpec</span><br><span class="line">newDp.Spec.Template.SetLabels(app.Labels)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := ctrl.SetControllerReference(app, newDp, r.Scheme); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Error(err, <span class="string">&quot;Failed to SetControllerReference, will requeue after a short time.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := r.Create(ctx, newDp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Error(err, <span class="string">&quot;Failed to create Deployment, will requeue after a short time.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Info(<span class="string">&quot;The Deployment has been created.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>至此，Deployment资源的调谐逻辑也就写好了。</p>
<h4 id="33-实现service调谐流程"><a class="markdownIt-Anchor" href="#33-实现service调谐流程"></a> 3.3 实现Service调谐流程</h4>
<p>我们继续实现Service的调谐过程。在controllers目录下，即与application_controller.go源文件同级目录内创建一个service.go源文件来实现Service的调谐逻辑。<br />
同样先看图，如图7-3所示，Service的调谐逻辑和Deployment基本一致。</p>
<p><img src="../images/service_reconcile.png" alt="service_reconcile" /></p>
<p>我们还是先查看代码，然后对照流程图中的步骤来详细解释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *ApplicationReconciler)</span></span> reconcileService(ctx context.Context, app *dappsv1.Application) (ctrl.Result, <span class="type">error</span>) &#123;</span><br><span class="line">	log := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> svc = &amp;corev1.Service&#123;&#125;</span><br><span class="line">	err := r.Get(ctx, types.NamespacedName&#123;</span><br><span class="line">		Namespace: app.Namespace,</span><br><span class="line">		Name:      app.Name,</span><br><span class="line">	&#125;, svc)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Info(<span class="string">&quot;The Service has already exist.&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> reflect.DeepEqual(svc.Status, app.Status.Network) &#123;</span><br><span class="line">			<span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		app.Status.Network = svc.Status</span><br><span class="line">		<span class="keyword">if</span> err := r.Status().Update(ctx, app); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Error(err, <span class="string">&quot;Failed to update Application status&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">		&#125;</span><br><span class="line">		log.Info(<span class="string">&quot;The Application status has been updated.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !errors.IsNotFound(err) &#123;</span><br><span class="line">		log.Error(err, <span class="string">&quot;Failed to get Service, will requeue after a short time.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	newSvc := &amp;corev1.Service&#123;&#125;</span><br><span class="line">	newSvc.SetName(app.Name)</span><br><span class="line">	newSvc.SetNamespace(app.Namespace)</span><br><span class="line">	newSvc.SetLabels(app.Labels)</span><br><span class="line">	newSvc.Spec = app.Spec.Service.ServiceSpec</span><br><span class="line">	newSvc.Spec.Selector = app.Labels</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := ctrl.SetControllerReference(app, newSvc, r.Scheme); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(err, <span class="string">&quot;Failed to SetControllerReference, will requeue after a short time.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := r.Create(ctx, newSvc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Error(err, <span class="string">&quot;Failed to create Service, will requeue after a short time.&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Info(<span class="string">&quot;The Service has been created.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="331-查询service"><a class="markdownIt-Anchor" href="#331-查询service"></a> 3.3.1 查询Service</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log := log.FromContext(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> svc = &amp;corev1.Service&#123;&#125;</span><br><span class="line">err := r.Get(ctx, types.NamespacedName&#123;</span><br><span class="line">	Namespace: app.Namespace,</span><br><span class="line">	Name:      app.Name,</span><br><span class="line">&#125;, svc)</span><br></pre></td></tr></table></figure>
<p>这一步同样是通过Application的Namespace和Name信息来查询资源的，我们这里尝试去Get Service，查看这个Service是否存在。</p>
<h5 id="332-没错误发生时更新状态"><a class="markdownIt-Anchor" href="#332-没错误发生时更新状态"></a> 3.3.2 没错误发生时，更新状态</h5>
<pre><code>if err == nil &#123;
	log.Info(&quot;The Service has already exist.&quot;)
	if reflect.DeepEqual(svc.Status, app.Status.Network) &#123;
		return ctrl.Result&#123;&#125;, nil
	&#125;

	app.Status.Network = svc.Status
	if err := r.Status().Update(ctx, app); err != nil &#123;
		log.Error(err, &quot;Failed to update Application status&quot;)
		return ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err
	&#125;
	log.Info(&quot;The Application status has been updated.&quot;)
	return ctrl.Result&#123;&#125;, nil
&#125;
</code></pre>
<p>这一步是通过比较svc.Status和app.Status.Network的差异来判断Service的Status是否发生了变化，如果有变化就去更新app.Status。</p>
<h5 id="333-notfound以外的错误场景"><a class="markdownIt-Anchor" href="#333-notfound以外的错误场景"></a> 3.3.3 NotFound以外的错误场景</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !errors.IsNotFound(err) &#123;</span><br><span class="line">	log.Error(err, <span class="string">&quot;Failed to get Service, will requeue after a short time.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NotFound之外的错误处理，这里没有新的知识点，我们同样选择在1分钟后重试。</p>
<h5 id="334-notfound的时候"><a class="markdownIt-Anchor" href="#334-notfound的时候"></a> 3.3.4 NotFound的时候</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">newSvc := &amp;corev1.Service&#123;&#125;</span><br><span class="line">newSvc.SetName(app.Name)</span><br><span class="line">newSvc.SetNamespace(app.Namespace)</span><br><span class="line">newSvc.SetLabels(app.Labels)</span><br><span class="line">newSvc.Spec = app.Spec.Service.ServiceSpec</span><br><span class="line">newSvc.Spec.Selector = app.Labels</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := ctrl.SetControllerReference(app, newSvc, r.Scheme); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Error(err, <span class="string">&quot;Failed to SetControllerReference, will requeue after a short time.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := r.Create(ctx, newSvc); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Error(err, <span class="string">&quot;Failed to create Service, will requeue after a short time.&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> ctrl.Result&#123;RequeueAfter: GenericRequeueDuration&#125;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Info(<span class="string">&quot;The Service has been created.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> ctrl.Result&#123;&#125;, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>如果Service不存在，就根据Application资源实例的信息来构造Service。至此，Service资源的调谐逻辑也就写好了。</p>
<h4 id="34-设置rbac权限"><a class="markdownIt-Anchor" href="#34-设置rbac权限"></a> 3.4 设置RBAC权限</h4>
<p>我们在前面实现Deployment和Service的调谐逻辑之后，其实还有一个问题没有考虑到，就是这个Operator程序默认是没有权限操作Deployment和Service资源的。当然，我们不需要自己去编写RBAC配置，只需通过几行注释标记代码，工具会自动帮助我们生成相应的配置文件。<br />
回到controllers/application_controller.go文件的Reconcile()方法，可以看到Reconcile()方法上面有这样几行注释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+kubebuilder:rbac:groups=apps.danielhu.cn,resources=applications,verbs=get;list;watch;create;update;patch;delete</span></span><br><span class="line"><span class="comment">//+kubebuilder:rbac:groups=apps.danielhu.cn,resources=applications/status,verbs=get;update;patch</span></span><br><span class="line"><span class="comment">//+kubebuilder:rbac:groups=apps.danielhu.cn,resources=applications/finalizers,verbs=update</span></span><br></pre></td></tr></table></figure>
<p>在下方添加操作Deployment和Service相关的注释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete</span></span><br><span class="line"><span class="comment">//+kubebuilder:rbac:groups=apps,resources=deployments/status,verbs=get</span></span><br><span class="line"><span class="comment">//+kubebuilder:rbac:groups=core,resources=services,verbs=get;list;watch;create;update;patch;delete</span></span><br><span class="line"><span class="comment">//+kubebuilder:rbac:groups=core,resources=services/status,verbs=get</span></span><br></pre></td></tr></table></figure>
<p>然后执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make manifests</span><br></pre></td></tr></table></figure>
<p><strong>报错</strong></p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: not all generators ran successfully</span><br><span class="line">run `controller-gen rbac:roleName=manager-role crd webhook paths=./... output:crd:artifacts:config=config/crd/bases -w` to see all available markers, or `controller-gen rbac:roleName=manager-role crd webhook paths=./... output:crd:artifacts:config=config/crd/bases -h` for usage</span><br><span class="line">make: *** [manifests] 错误 1</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>通过gpt提示，此处是缺少controller-gen工具，我下载并配置好了controller-gen，把它放在了相应的目录下。后面再次执行make manifests还是缺少一些工具，把他们下载下来就好了。</p>
<p>通过和gpt交互，其实我明白了一个问题：<strong>K8s在运行代码时报错，错误的关键信息往往在Error句的上面那句</strong>，因为K8s中它错误只指出<code>not all generators ran successfully</code> 这样一句废话，所以这里我们必须改掉自己写程序时候的习惯，**从Error往下看，这样是找不到错误的！**我之前真是太愚蠢了！</p>
<p>GPT是真的挺靠谱的！</p>
</blockquote>
<p>执行成功(来之不易)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master application-operator]# make manifests</span><br><span class="line">/root/MyOPeratorProjects/application-operator/bin/controller-gen rbac:roleName=manager-role crd webhook paths=&quot;./...&quot; output:crd:artifacts:config=config/crd/ba</span><br></pre></td></tr></table></figure>
<p>这时打开config/rbac/目录下的role.yaml，可以看到如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">manager-role</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apps</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deployments</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">delete</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apps</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deployments/status</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apps.danielhu.cn</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">applications</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">delete</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apps.danielhu.cn</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">applications/finalizers</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apps.danielhu.cn</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">applications/status</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">delete</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">services/status</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br></pre></td></tr></table></figure>
<h4 id="35-过滤调谐事件"><a class="markdownIt-Anchor" href="#35-过滤调谐事件"></a> 3.5 过滤调谐事件</h4>
<blockquote>
<p>Notes：</p>
<p>以上内容均为个人学习过程中的理解，理解和总结可能有偏差。文章内容会随着学习过程不断修改完善。</p>
<p>如果以上有错误欢迎指出。</p>
</blockquote>

</div>

<!-- post-guide -->

    <div class="post-guide">
        <div class="item left">
            
              <a href="/2023/04/27/7.5.%20%E3%80%90%E6%95%85%E9%9A%9C%E3%80%91%E4%B8%80%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%99%BB%E9%99%86%E4%B8%8D%E8%BF%9B%E5%8E%BB%E4%BA%86/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  【故障】一台虚拟机登陆不进去了
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2023/04/27/8.%20k8s%20api%E5%AD%A6%E4%B9%A0/">
                Kubernetes api学习
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>


<!-- comment - giscus -->


<!-- comment - valine -->


<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©<span id="footerYear-start"></span>-<span id="footerYear-end"></span>
	<a href="/">John Doe</a> 
	
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>


<script type="text/javascript">
	document.getElementById('footerYear-start').innerHTML = new Date().getFullYear() + '';
</script>

<script type="text/javascript">
	document.getElementById('footerYear-end').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>