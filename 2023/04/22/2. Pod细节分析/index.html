<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		Pod细节分析 | 
	 
	Hexo
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	


	<!-- search -->
	<script>
		var searchEngine = "https://www.google.com/search?q=";
		if(typeof searchEngine == "undefined" || searchEngine == null || searchEngine == ""){
			searchEngine = "https://www.google.com/search?q=";
		}
		var homeHost = "";
		if(typeof homeHost == "undefined" || homeHost == null || homeHost == ""){
			homeHost = window.location.host;
		}
	</script>


	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">


	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>


	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@v1.5.1/dist/Valine.min.js"></script>

	
	

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
	
<header id="header">
    <a id="title" href="/" class="logo">Hexo</a>

	<ul id="menu">
    

    

    

    
      
      
        <li class="menu-item">
          <a href='https://github.com/NikeSong' class="menu-item-link" target="_blank">
            Tree
          </a>
        </li>
      
        <li class="menu-item">
          <a href='https://github.com/NikeSong' class="menu-item-link" target="_blank">
            UidGenerator
          </a>
        </li>
      
    
  
    
      <li class="menu-item">
        <a href='https://github.com/NikeSong' class="menu-item-link" target="_blank">
          <i class="fa fa-github fa-2x"></i>
        </a>
      </li>
    
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="search" placeholder="按回车全站搜索">
		<div id="tree">
			

			
							<ul>
								<li class="file">
									<a href="/2023/04/21/1.%20Kubernetes%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">
                     
										    Kubernetes基本结构
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2023/04/22/2.%20Pod%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/">
                     
										    Pod细节分析
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/23/4.%20K8s%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/">
                     
										    K8s服务暴露
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2023/04/22/7.%20%E6%8E%A2%E7%A7%98Docker%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">
                     
										    探秘Docker容器的实现原理
                     
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">
	Pod细节分析
</h1>

<!-- meta -->
<div class="article-meta">
	

	<span>John Doe</span>
	<span>2023-04-22 13:10:00</span>

  <div id="article-categories">
    
		  <span>Categories：</span>
      
          
              <span>
                  <i class="fa fa-folder" aria-hidden="true">
                  <a href="/categories/Kubernetes学习笔记/">Kubernetes学习笔记</a>
                  </i>
                
              </span>
          
      
    

    
		    <span>Tags：</span>
        
    
  </div>

</div>

<!-- content -->
<div id="article-content">
	<blockquote>
<p><strong>操作K8s的两种方式</strong></p>
<p>我们日常操作K8s资源的方式可以分为两类，一类是直接编写一语句写清当前要执行的工作，比如</p>
<p><code>kubectl run nginx-pod --image=nginx:1.17.1</code></p>
<p>通过这样简单的一条语句就可以创建一个Pod，其镜像为nginx:1.17.1，如果本地机器没有这个镜像，K8s会自动去镜像库下载。</p>
<p>但是其实一个Pod的可配置信息有很多，或者更宽泛的说，K8s中的各种资源，包括Pod Controller，Namespace等的可配置项都是很多的。如果我们想创建一个新的资源，通过命令事无巨细的描述清楚是很困难和不方便的，所以更多时候我们采用的是另一种方式，即通过yaml文件创建。</p>
<p>这种模式下我们把一个资源相关的配置信息全都写进yaml文件中，然后直接使用</p>
<p><code>kubectl create/patch/apply -f nginx-pod.yaml</code></p>
<p>一句简单的指令就可以了。</p>
</blockquote>
<h3 id="1-Pod基础"><a href="#1-Pod基础" class="headerlink" title="1 Pod基础"></a>1 Pod基础</h3><h4 id="1-1-Pause容器"><a href="#1-1-Pause容器" class="headerlink" title="1.1 Pause容器"></a>1.1 Pause容器</h4><p>上文我们说了Pod就像一个豆荚，里面运行着容器。这些容器里面有一个显得尤为特殊，它叫做Pause。</p>
<p><img src="/../images/pod_pause.png" alt="pod_pause"></p>
<p>Pause容器又叫根容器，它随Pod的建立而建立，其他pod都会从pause容器中fork出来。它掌握了此Pod的网络栈和存储资源。同一Pod的容器可以共享Pause的网络栈和Volume存储（Volume是Pod中能够被多个容器访问的共享目录），因此他们之间通信和数据交换更为高效，在设计时我们可以充分利用这一特性将一组密切相关的服务进程放入同一个Pod中。同一个Pod里的容器之间仅需通过localhost就能互相通信。</p>
<h4 id="1-2-Pod的标签"><a href="#1-2-Pod的标签" class="headerlink" title="1.2 Pod的标签"></a>1.2 Pod的标签</h4><h3 id="2-Pod的生命周期"><a href="#2-Pod的生命周期" class="headerlink" title="2 Pod的生命周期"></a>2 Pod的生命周期</h3><p>我们一般将pod对象从创建至终的这段时间范围称为pod的生命周期，它主要包含下面的过程：</p>
<ul>
<li><p>pod创建过程</p>
</li>
<li><p>运行初始化容器（init container）过程</p>
</li>
<li><p>运行主容器（main container）</p>
<ul>
<li><p>容器启动后钩子（post start）、容器终止前钩子（pre stop）</p>
</li>
<li><p>容器的存活性探测（liveness probe）、就绪性探测（readiness probe）</p>
</li>
</ul>
</li>
<li><p>pod终止过程</p>
</li>
</ul>
<p>下面逐一介绍各个过程中涉及到的技术细节，各个组件的配合实现方法。</p>
<h4 id="2-1-Pod的创建"><a href="#2-1-Pod的创建" class="headerlink" title="2.1 Pod的创建"></a>2.1 Pod的创建</h4><p><img src="/../images/Pod_create.png" alt="Pod_create"></p>
<ul>
<li><p>首先用户通过kubectl提交需要创建的pod信息给Api Server。</p>
</li>
<li><p>Api Server开始生成pod对象的信息，并将信息存入etcd，然后立即返回确认信息至客户端。</p>
</li>
</ul>
<p><img src="/../images/pod_init.png" alt="pod_init"></p>
<ul>
<li>Api Server开始读取etcd中的Pod信息，反映其中pod对象的变化，其它组件使用watch机制来跟踪检查Api Server上的变动。</li>
</ul>
<p><img src="/../images/pod_init2.png" alt="pod_init2"></p>
<ul>
<li><p>scheduler发现有新的pod对象要创建，开始为Pod分配主机并将结果信息更新至Api Server。</p>
</li>
<li><p>node节点上的kubelet发现有pod调度过来，开始工作。</p>
</li>
</ul>
<p><img src="/../images/pod_init3.png" alt="pod_init3"></p>
<ul>
<li>Kubelet尝试创建容器，并将创建结果回送至Api Server。</li>
<li>Api Server将接收到的pod状态信息存入etcd中。</li>
</ul>
<p>通过以上过程就更加看出Api Server是Master中各组件工作的核心，各个组件都在监听Api Server中Pod的状态变化，当某Pod的当前状态需要自己做相应工作才能进一步推动时就会开始工作，并将做完后的结果同步到Api Server中。</p>
<h4 id="2-2-Pod的生存过程"><a href="#2-2-Pod的生存过程" class="headerlink" title="2.2 Pod的生存过程"></a>2.2 Pod的生存过程</h4><p>在创建后的整个生命周期中，Pod会出现5种<strong>状态</strong>（<strong>相位</strong>），分别如下：</p>
<ul>
<li>挂起（Pending）：apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</li>
<li>运行中（Running）：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成</li>
<li>成功（Succeeded）：pod中的所有容器都已经成功终止并且不会被重启</li>
<li>失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</li>
<li>未知（Unknown）：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致</li>
</ul>
<p><img src="/../images/lifetime.png" alt="lifetime"></p>
<p><strong>初始化容器</strong></p>
<p>初始化容器是在pod的主容器启动之前要运行的容器，可以有一个或者多个。它主要是做一些主容器的前置工作，具有两大特征：</p>
<ol>
<li>初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成。</li>
<li>初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行。</li>
</ol>
<p>初始化容器有很多的应用场景，比如提供主容器镜像中不具备的工具程序或自定义代码。此外，初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足。</p>
<p><strong>钩子函数</strong></p>
<p>钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。</p>
<p>kubernetes在主容器的启动之后和停止之前提供了两个钩子函数：</p>
<ul>
<li>post start：容器创建之后执行，如果失败了会重启容器。</li>
<li>pre stop  ：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作。</li>
</ul>
<p><strong>容器探测</strong></p>
<p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例” 摘除 “，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：</p>
<ul>
<li>liveness probes：存活性探针，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器</li>
<li>readiness probes：就绪性探针，用于检测应用实例当前是否可以接收请求，如果不能，k8s不会转发流量</li>
</ul>
<p><strong>重启策略</strong></p>
<p>一旦容器探测出现了问题，kubernetes就会对容器所在的Pod进行重启，其实这是由pod的重启策略决定的，pod的重启策略有 3 种，分别如下：</p>
<ul>
<li>Always ：容器失效时，自动重启该容器，这也是默认值。</li>
<li>OnFailure ： 容器终止运行且退出码不为0时重启</li>
<li>Never ： 不论状态为何，都不重启该容器</li>
</ul>
<p>​    重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长。</p>
<h4 id="2-3-Pod的终止过程"><a href="#2-3-Pod的终止过程" class="headerlink" title="2.3 Pod的终止过程"></a>2.3 Pod的终止过程</h4><p><img src="/../images/pod_terminate.png" alt="pod_terminate"></p>
<p>这个过程同样是Master中各个组件合作完成的，此处不再做细节展示。</p>
<ul>
<li><p>用户向Api Server发送删除pod对象的命令。</p>
</li>
<li><p>Api Servcer中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead。</p>
</li>
<li><p>将pod标记为terminating状态。</p>
</li>
</ul>
<p><img src="/../images/pod_terminate3.png" alt="pod_terminate3"></p>
<ul>
<li>kubelet在监控到pod对象转为terminating状态的同时启动pod关闭过程。</li>
<li>端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除。</li>
<li>如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式启动执行。</li>
<li>pod对象中的容器进程收到停止信号。</li>
<li>宽限期结束后，若pod中还存在仍在运行的进程，那么pod对象会收到立即终止的信号。</li>
<li>kubelet请求Api Server将此pod资源的宽限期设置为0从而完成删除操作，此时pod对于用户已不可见。</li>
</ul>
<h3 id="3-Pod的调度"><a href="#3-Pod的调度" class="headerlink" title="3 Pod的调度"></a>3 Pod的调度</h3><p>我们知道Master中的组件Scheduler的功能就是把Pod分配到它认为最优的Node中，分配的策略是多样的，这样使得我们可以更加合理、充分的利用集群的资源。但是很多时候我们对于这种自动调度并不感到满足，比如我们想把功能相关的Pod放到同一个Node中，如此这些Pod的通信在本Node中即可以完成，这显然节省了大量的IO、网络资源。</p>
<p>K8s提供了这样的功能，总结起来，在K8s中，调度总共可以分为四种：</p>
<h4 id="3-1-自动调度"><a href="#3-1-自动调度" class="headerlink" title="3.1 自动调度"></a>3.1 自动调度</h4><p>运行在哪个节点上完全由Scheduler经过一系列的算法计算得出。</p>
<h4 id="3-2-定向调度"><a href="#3-2-定向调度" class="headerlink" title="3.2 定向调度"></a>3.2 定向调度</h4><p>强制约束将Pod调度到指定的Name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。如果某节点不存在或出现故障，Pod也会向上面进行调度，然后显示调度失败。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodename</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">nodeName:</span> <span class="string">node1</span> <span class="comment"># 指定调度到node1节点上</span></span><br></pre></td></tr></table></figure>



<h4 id="3-3-亲和性调度"><a href="#3-3-亲和性调度" class="headerlink" title="3.3 亲和性调度"></a>3.3 亲和性调度</h4><p>上面的强制调度无疑是不够好的，若因为操作人员失误，Pod就真的运行不起来放在那里，这合理吗？不合理。</p>
<p>所以我们需要以温和的方式，建议K8s把某Pod调度到某节点。这就是亲和性调度。</p>
<p>亲和性调度可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有，也可以调度到不满足条件的节点上，使调度更加灵活。</p>
<p>亲和性设置（Affinity）主要分为三类：</p>
<ul>
<li>nodeAffinity(node亲和性）: 以node为目标，解决pod可以调度到哪些node的问题</li>
<li>podAffinity(pod亲和性) :  以pod为目标，解决pod可以和哪些已存在的pod部署在同一个拓扑域中的问题</li>
<li>podAntiAffinity(pod反亲和性) :  以pod为目标，解决pod不能和哪些已存在pod部署在同一个拓扑域中的问题</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-preferred</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment">#设置node亲和性</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 软限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签(当前环境没有)</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br></pre></td></tr></table></figure>



<h4 id="3-4-基于污点和容忍的调度"><a href="#3-4-基于污点和容忍的调度" class="headerlink" title="3.4 基于污点和容忍的调度"></a>3.4 基于污点和容忍的调度</h4><p><strong>污点（Taints）</strong></p>
<p>​    前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加<strong>污点</strong>属性，来决定是否允许Pod调度过来。</p>
<p>​    Node被设置上污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去。</p>
<p>污点的格式为<code>key=value:effect</code>, key和value是污点的标签，effect描述污点的作用，支持如下三个选项：</p>
<ul>
<li>PreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可调度</li>
<li>NoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但不会影响当前Node上已存在的Pod</li>
<li>NoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已存在的Pod驱离</li>
</ul>
<p><img src="/../images/flaw.png" alt="flaw"></p>
<p>使用kubectl设置和去除污点的命令示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置污点</span></span><br><span class="line">kubectl taint nodes node1 key=value:effect</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去除污点</span></span><br><span class="line">kubectl taint nodes node1 key:effect-</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去除所有污点</span></span><br><span class="line">kubectl taint nodes node1 key-</span><br></pre></td></tr></table></figure>



<p><strong>容忍（Toleration）</strong></p>
<p>上面介绍了污点的作用，我们可以在node上添加污点用于拒绝pod调度上来，但是如果就是想将一个pod调度到一个有污点的node上去，这时候应该怎么做呢？这就要使用到<strong>容忍</strong>。污点就是拒绝，容忍就是忽略，Node通过污点拒绝pod调度上去，Pod通过容忍忽略拒绝。</p>
<p><img src="/../images/ressitence.png" alt="ressitence"></p>
<p>设置方式如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-toleration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">tolerations:</span>      <span class="comment"># 添加容忍</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;tag&quot;</span>        <span class="comment"># 要容忍的污点的key</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span> <span class="comment"># 操作符</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&quot;heima&quot;</span>    <span class="comment"># 容忍的污点的value</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">&quot;NoExecute&quot;</span>   <span class="comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span></span><br></pre></td></tr></table></figure>



<h3 id="4-总结：从配置文件看Pod"><a href="#4-总结：从配置文件看Pod" class="headerlink" title="4 总结：从配置文件看Pod"></a>4 总结：从配置文件看Pod</h3><h4 id="4-2-Pod配置清单"><a href="#4-2-Pod配置清单" class="headerlink" title="4.2 Pod配置清单"></a>4.2 Pod配置清单</h4><p>在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：</p>
<ul>
<li><p>apiVersion   &lt;string&gt;     版本，由kubernetes内部定义，版本号必须可以用 kubectl api-versions 查询到</p>
</li>
<li><p>kind &lt;string&gt;                类型，由kubernetes内部定义，版本号必须可以用 kubectl api-resources 查询到</p>
</li>
<li><p>metadata   &lt;Object&gt;     元数据，主要是资源标识和说明，常用的有name、namespace、labels等</p>
</li>
<li><p>spec &lt;Object&gt;               描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述                </p>
</li>
<li><p>status  &lt;Object&gt;            状态信息，里面的内容不需要定义，由kubernetes自动生成</p>
</li>
</ul>
<p>在上面的属性中，spec是接下来研究的重点，继续看下它的常见子属性:</p>
<ul>
<li>containers   &lt;[]Object&gt;       容器列表，用于定义容器的详细信息 </li>
<li>nodeName &lt;String&gt;           根据nodeName的值将pod调度到指定的Node节点上</li>
<li>nodeSelector   &lt;map[]&gt;      根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上</li>
<li>hostNetwork  &lt;boolean&gt;    是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</li>
<li>volumes      &lt;[]Object&gt;       存储卷，用于定义Pod上面挂在的存储信息 </li>
<li>restartPolicy	&lt;string&gt;       重启策略，表示Pod在遇到故障的时候的处理策略</li>
</ul>
<p>Pod简单常用配置文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>     <span class="comment">#必选，版本号，例如v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       　 <span class="comment">#必选，资源类型，例如 Pod</span></span><br><span class="line"><span class="attr">metadata:</span>       　 <span class="comment">#必选，元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span>     <span class="comment">#必选，Pod名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">string</span>  <span class="comment">#Pod所属的命名空间,默认为&quot;default&quot;</span></span><br><span class="line">  <span class="attr">labels:</span>       　　  <span class="comment">#自定义标签列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　          </span><br><span class="line"><span class="attr">spec:</span>  <span class="comment">#必选，Pod中容器的详细定义</span></span><br><span class="line">  <span class="attr">containers:</span>  <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>   <span class="comment">#必选，容器名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">string</span>  <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> [ <span class="string">Always|Never|IfNotPresent</span> ]  <span class="comment">#获取镜像的策略 </span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">string</span>]   <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">string</span>]      <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">string</span>  <span class="comment">#容器的工作目录</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>       <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">string</span> <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="string">boolean</span> <span class="comment">#是否为只读模式</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>        <span class="comment">#端口的名称</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="string">int</span>  <span class="comment">#容器需要监听的端口号</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="string">int</span>       <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">string</span>    <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line">    <span class="attr">env:</span>   <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>  <span class="comment">#环境变量名称</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">string</span> <span class="comment">#环境变量的值</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment">#资源限制和请求的设置</span></span><br><span class="line">      <span class="attr">limits:</span>  <span class="comment">#资源限制的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>     <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>  <span class="comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class="line">      <span class="attr">requests:</span> <span class="comment">#资源请求的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>    <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span> <span class="comment">#内存请求,容器启动的初始可用数量</span></span><br><span class="line">    <span class="attr">lifecycle:</span> <span class="comment">#生命周期钩子</span></span><br><span class="line">		<span class="attr">postStart:</span> <span class="comment">#容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启</span></span><br><span class="line">		<span class="attr">preStop:</span> <span class="comment">#容器终止前执行此钩子,无论结果如何,容器都会终止</span></span><br><span class="line">    <span class="attr">livenessProbe:</span>  <span class="comment">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器</span></span><br><span class="line">      <span class="attr">exec:</span>       　 <span class="comment">#对Pod容器内检查方式设置为exec方式</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">string</span>]  <span class="comment">#exec方式需要制定的命令或脚本</span></span><br><span class="line">      <span class="attr">httpGet:</span>       <span class="comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">HttpHeaders:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> [<span class="string">Always</span> <span class="string">|</span> <span class="string">Never</span> <span class="string">|</span> <span class="string">OnFailure</span>]  <span class="comment">#Pod的重启策略</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">&lt;string&gt;</span> <span class="comment">#设置NodeName表示将该Pod调度到指定到名称的node节点上</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="string">obeject</span> <span class="comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span> <span class="comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure>







<blockquote>
<p>Notes：</p>
<p>以上内容均为个人学习过程中的理解，理解和总结可能有偏差。文章内容会随着学习过程不断修改完善。</p>
<p>如果以上有错误欢迎指出。</p>
</blockquote>

</div>

<!-- post-guide -->

    <div class="post-guide">
        <div class="item left">
            
              <a href="/2023/04/23/4.%20K8s%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  K8s服务暴露
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2023/04/22/7.%20%E6%8E%A2%E7%A7%98Docker%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">
                探秘Docker容器的实现原理
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>


<!-- comment - giscus -->


<!-- comment - valine -->


<script>
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©<span id="footerYear-start"></span>-<span id="footerYear-end"></span>
	<a href="/">John Doe</a> 
	
	
	<br>
	Nicolson的博客
	</p>
</div>


<script type="text/javascript">
	document.getElementById('footerYear-start').innerHTML = new Date().getFullYear() + '';
</script>

<script type="text/javascript">
	document.getElementById('footerYear-end').innerHTML = new Date().getFullYear() + '';
</script>

	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>